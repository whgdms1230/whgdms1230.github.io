---
sort: 2
---

# Tutorials

## 0. 참고 문헌
*- [CycloneDDS Githug HelloWorld pages](https://github.com/eclipse-cyclonedds/cyclonedds/tree/master/examples/helloworld)*

## 1. Tutorials

cyclonedds 설치 시 기본으로 제공되는 example인 HelloWorld에 대한 내용이다. helloworld 예제를 보면 다음과 같이 구성되어 있다.

```bash
helloworld
├── CMakeLists.txt
├── HelloWorldData.idl
├── publisher.c
└── subscriber.c
```

## 2. CMakeLists.txt
먼저 `CMakeLists.txt` 의 내용이다.
```cmake
#
# Copyright(c) 2021 ADLINK Technology Limited and others
#
# This program and the accompanying materials are made available under the
# terms of the Eclipse Public License v. 2.0 which is available at
# http://www.eclipse.org/legal/epl-2.0, or the Eclipse Distribution License
# v. 1.0 which is available at
# http://www.eclipse.org/org/documents/edl-v10.php.
#
# SPDX-License-Identifier: EPL-2.0 OR BSD-3-Clause
#
project(helloword LANGUAGES C)
cmake_minimum_required(VERSION 3.10)

if(NOT TARGET CycloneDDS::ddsc)
  # Find the CycloneDDS package.
  find_package(CycloneDDS REQUIRED)
endif()

# This is a convenience function, provided by the CycloneDDS package,
# that will supply a library target related the the given idl file.
# In short, it takes the idl file, generates the source files with
# the proper data types and compiles them into a library.
idlc_generate(TARGET HelloWorldData_lib FILES "HelloWorldData.idl")

# Both executables have only one related source file.
add_executable(HelloworldPublisher publisher.c)
add_executable(HelloworldSubscriber subscriber.c)

# Both executables need to be linked to the idl data type library and
# the ddsc API library.
target_link_libraries(HelloworldPublisher HelloWorldData_lib CycloneDDS::ddsc)
target_link_libraries(HelloworldSubscriber HelloWorldData_lib CycloneDDS::ddsc)
```

여기서 `idlc_generate`는 `HelloWorldData.idl`라는 idl 형태의 파일을 이용하여 `HelloWorldData.c` 와 `HelloWorldData.h`를 만들어내는 컴파일러이다.

다음으로 `add_executable`과 `target_link_libraries`는 `publisher.c`와 `subscriber.c`파일을 이용하여 실행 가능한 라이브러리를 만들기 위해 선언되었다.

## 3. HelloWorldData.idl

`.idl` 파일은 CycloneDDS의 메세지 형태를 정의한 파일이다. 다음은 HelloWorldData.idl에 정의된 Msg 파일이다. 

```idl
module HelloWorldData
{
  struct Msg
  {
    long userID;
    string message;
  };
  #pragma keylist Msg userID
};
```

### 3.1 HelloWorldData.h

다음은 HelloWorldData.idl을 컴파일하여 생성된 헤더파일이다. 해당 헤더파일은 위에서 정의된 Msg 구조체를 dds에서 사용되는 HelloWorldData_Msg 형태로 변환된 것이다. `HelloWorldData_Msg__alloc()`은 HelloWorldData_Msg을 힙 영역에 할당하기 위해 사용되며, `HelloWorldData_Msg_free(d,o)`는 힙에 할당된 데이터를 해제할 때 사용된다. 

```c
/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to C Translator
  File name: HelloWorldData.h
  Source: HelloWorldData.idl
  Cyclone DDS: V0.9.0

*****************************************************************/
#ifndef DDSC_HELLOWORLDDATA_H
#define DDSC_HELLOWORLDDATA_H

#include "dds/ddsc/dds_public_impl.h"

#ifdef __cplusplus
extern "C" {
#endif

typedef struct HelloWorldData_Msg
{
  int32_t userID;
  char * message;
} HelloWorldData_Msg;

extern const dds_topic_descriptor_t HelloWorldData_Msg_desc;

#define HelloWorldData_Msg__alloc() \
((HelloWorldData_Msg*) dds_alloc (sizeof (HelloWorldData_Msg)));

#define HelloWorldData_Msg_free(d,o) \
dds_sample_free ((d), &HelloWorldData_Msg_desc, (o))

#ifdef __cplusplus
}
#endif

#endif /* DDSC_HELLOWORLDDATA_H */
```

### 3.2 HelloWorldData.c

다음은 HelloWorldData.idl을 컴파일하여 생성된 소스파일이다. 해당 소스코드는 해당 메세지를 이용해 DDS 통신하는데 필요한 객체들을 선언한 파일이다.

```c
/****************************************************************

  Generated by Eclipse Cyclone DDS IDL to C Translator
  File name: HelloWorldData.c
  Source: HelloWorldData.idl
  Cyclone DDS: V0.9.0

*****************************************************************/
#include "HelloWorldData.h"

static const uint32_t HelloWorldData_Msg_ops [] =
{
  /* Msg */
  DDS_OP_ADR | DDS_OP_TYPE_4BY | DDS_OP_FLAG_SGN | DDS_OP_FLAG_KEY, offsetof (HelloWorldData_Msg, userID),
  DDS_OP_ADR | DDS_OP_TYPE_STR, offsetof (HelloWorldData_Msg, message),
  DDS_OP_RTS,
  
  /* key: userID */
  DDS_OP_KOF | 1, 0u /* order: 0 */
};

static const dds_key_descriptor_t HelloWorldData_Msg_keys[1] =
{
  { "userID", 5, 0 }
};

const dds_topic_descriptor_t HelloWorldData_Msg_desc =
{
  .m_size = sizeof (HelloWorldData_Msg),
  .m_align = sizeof (char *),
  .m_flagset = DDS_TOPIC_NO_OPTIMIZE | DDS_TOPIC_FIXED_KEY | DDS_TOPIC_FIXED_KEY_XCDR2,
  .m_nkeys = 1u,
  .m_typename = "HelloWorldData::Msg",
  .m_keys = HelloWorldData_Msg_keys,
  .m_nops = 3,
  .m_ops = HelloWorldData_Msg_ops,
  .m_meta = ""
};
```

## 4. publisher.c

다음은 위에서 선언된 HelloWorldData의 Msg를 이용하여 메세지를 publish하는 소스코드이다.

```c
#include "dds/dds.h"
#include "HelloWorldData.h"
#include <stdio.h>
#include <stdlib.h>

int main (int argc, char ** argv)
{
  dds_entity_t participant;
  dds_entity_t topic;
  dds_entity_t writer;
  dds_return_t rc;
  HelloWorldData_Msg msg;
  uint32_t status = 0;
  (void)argc;
  (void)argv;

  /* Create a Participant. */
  participant = dds_create_participant (DDS_DOMAIN_DEFAULT, NULL, NULL);
  if (participant < 0)
    DDS_FATAL("dds_create_participant: %s\n", dds_strretcode(-participant));

  /* Create a Topic. */
  topic = dds_create_topic (
    participant, &HelloWorldData_Msg_desc, "HelloWorldData_Msg", NULL, NULL);
  if (topic < 0)
    DDS_FATAL("dds_create_topic: %s\n", dds_strretcode(-topic));

  /* Create a Writer. */
  writer = dds_create_writer (participant, topic, NULL, NULL);
  if (writer < 0)
    DDS_FATAL("dds_create_writer: %s\n", dds_strretcode(-writer));

  printf("=== [Publisher]  Waiting for a reader to be discovered ...\n");
  fflush (stdout);

  rc = dds_set_status_mask(writer, DDS_PUBLICATION_MATCHED_STATUS);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_set_status_mask: %s\n", dds_strretcode(-rc));

  while(!(status & DDS_PUBLICATION_MATCHED_STATUS))
  {
    rc = dds_get_status_changes (writer, &status);
    if (rc != DDS_RETCODE_OK)
      DDS_FATAL("dds_get_status_changes: %s\n", dds_strretcode(-rc));

    /* Polling sleep. */
    dds_sleepfor (DDS_MSECS (20));
  }

  /* Create a message to write. */
  msg.userID = 1;
  msg.message = "Hello World";

  printf ("=== [Publisher]  Writing : ");
  printf ("Message (%"PRId32", %s)\n", msg.userID, msg.message);
  fflush (stdout);

  rc = dds_write (writer, &msg);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_write: %s\n", dds_strretcode(-rc));

  /* Deleting the participant will delete all its children recursively as well. */
  rc = dds_delete (participant);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_delete: %s\n", dds_strretcode(-rc));

  return EXIT_SUCCESS;
}
```

* 먼저 dds 함수를 사용하기 위해 `dds/dds.h`를 가져오고, HelloWorldData.idl을 이용하여 만든 `HelloWorldData.h`를 가져온다.

```c
#include "dds/dds.h"
#include "HelloWorldData.h"
#include <stdio.h>
#include <stdlib.h>
```

* 다음으로, dds를 이용하여 publish 하기 위해 필요한 객체들을 생성한다. `participant`는 dds 통신을 위해 선언되는 객체이며, `topic`은 dds 메세지 형태를 구현하고, `write`는 dds를 이용하여 메세지를 전송하는 역할을 한다. `dds_return_t`로 선언된 `rc`는 dds 함수의 리턴값을 받기 위해 사용된다.
* `HelloWorldData_Msg`로 선언된 `msg`는 위에서 선안한 메세지 형태로 데이터를 저장할 수 있는 구조로, msg에 저장되어있는 데이터 형태데로 dds 메세지 통신을 할 수 있다.

```c
  dds_entity_t participant;
  dds_entity_t topic;
  dds_entity_t writer;
  dds_return_t rc;
  HelloWorldData_Msg msg;
  uint32_t status = 0;
  (void)argc;
  (void)argv;
```

* 다음은 `participant`를 `dds_create_particiapnt()` 함수로 생성하는 코드이다.

```c
  /* Create a Participant. */
  participant = dds_create_participant (DDS_DOMAIN_DEFAULT, NULL, NULL);
  if (participant < 0)
    DDS_FATAL("dds_create_participant: %s\n", dds_strretcode(-participant));
```

* 다음은 `topic`을 `dds_create_topic()` 함수로 생성하는 코드이다. 해당 함수는 앞에서 선언한 `participant`를 인자로 가져오며, `HelloWorldData.c`에 생성된 `HelloWorldData_Msg_desc`를 인자로 입력한다. 그리고 `topic`의 이름인 `"HelloWorldData_Msg"`를 입력한다.

```c
  /* Create a Topic. */
  topic = dds_create_topic (
    participant, &HelloWorldData_Msg_desc, "HelloWorldData_Msg", NULL, NULL);
  if (topic < 0)
    DDS_FATAL("dds_create_topic: %s\n", dds_strretcode(-topic));
```

* 다음은 `write`를 `dds_create_writer()` 함수로 생성하는 코드이다. 해당 함수는 앞에서 생성한 `participant`와 `topic`을 인자로 가져온다.

```c
  /* Create a Writer. */
  writer = dds_create_writer (participant, topic, NULL, NULL);
  if (writer < 0)
    DDS_FATAL("dds_create_writer: %s\n", dds_strretcode(-writer));

  printf("=== [Publisher]  Waiting for a reader to be discovered ...\n");
  fflush (stdout);
```

* 다음 부분은 dds를 설정하고, 특정 상태가 되도록 대기하는 코드인 것 같다.

```c
  printf("=== [Publisher]  Waiting for a reader to be discovered ...\n");
  fflush (stdout);

  rc = dds_set_status_mask(writer, DDS_PUBLICATION_MATCHED_STATUS);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_set_status_mask: %s\n", dds_strretcode(-rc));

  while(!(status & DDS_PUBLICATION_MATCHED_STATUS))
  {
    rc = dds_get_status_changes (writer, &status);
    if (rc != DDS_RETCODE_OK)
      DDS_FATAL("dds_get_status_changes: %s\n", dds_strretcode(-rc));

    /* Polling sleep. */
    dds_sleepfor (DDS_MSECS (20));
  }
```

* 다음으로 `msg`에 `HelloWorldData_Msg` 데이터 구조대로 데이터를 저장한다.

```c
  /* Create a message to write. */
  msg.userID = 1;
  msg.message = "Hello World";

  printf ("=== [Publisher]  Writing : ");
  printf ("Message (%"PRId32", %s)\n", msg.userID, msg.message);
  fflush (stdout);
```

* `dds_write()`함수를 이용하여, 메세지를 송신하는 객체인 `writer`를 통해 데이터를 저장한 msg를 dds로 뿌린다.

```c
  rc = dds_write (writer, &msg);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_write: %s\n", dds_strretcode(-rc));
```

* 데이터를 전송을 완료하고, dds 전송이 끝났다면, `dds_delete()`함수를 이용하여 `participant` 객체를 제거하고, `EXIT_SUCCESS`를 리턴함으로써 코드를 종료한다.

```c
  /* Deleting the participant will delete all its children recursively as well. */
  rc = dds_delete (participant);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_delete: %s\n", dds_strretcode(-rc));

  return EXIT_SUCCESS;
}    
```

## 5. subscriber.c

다음은 `subscriber.c` 소스코드이며, 해당 소스코드는 `publisher.c`에서 보낸 메세지를 받는 역할을 한다.

```c
#include "dds/dds.h"
#include "HelloWorldData.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

/* An array of one message (aka sample in dds terms) will be used. */
#define MAX_SAMPLES 1

int main (int argc, char ** argv)
{
  dds_entity_t participant;
  dds_entity_t topic;
  dds_entity_t reader;
  HelloWorldData_Msg *msg;
  void *samples[MAX_SAMPLES];
  dds_sample_info_t infos[MAX_SAMPLES];
  dds_return_t rc;
  dds_qos_t *qos;
  (void)argc;
  (void)argv;

  /* Create a Participant. */
  participant = dds_create_participant (DDS_DOMAIN_DEFAULT, NULL, NULL);
  if (participant < 0)
    DDS_FATAL("dds_create_participant: %s\n", dds_strretcode(-participant));

  /* Create a Topic. */
  topic = dds_create_topic (
    participant, &HelloWorldData_Msg_desc, "HelloWorldData_Msg", NULL, NULL);
  if (topic < 0)
    DDS_FATAL("dds_create_topic: %s\n", dds_strretcode(-topic));

  /* Create a reliable Reader. */
  qos = dds_create_qos ();
  dds_qset_reliability (qos, DDS_RELIABILITY_RELIABLE, DDS_SECS (10));
  reader = dds_create_reader (participant, topic, qos, NULL);
  if (reader < 0)
    DDS_FATAL("dds_create_reader: %s\n", dds_strretcode(-reader));
  dds_delete_qos(qos);

  printf ("\n=== [Subscriber] Waiting for a sample ...\n");
  fflush (stdout);

  /* Initialize sample buffer, by pointing the void pointer within
   * the buffer array to a valid sample memory location. */
  samples[0] = HelloWorldData_Msg__alloc ();

  /* Poll until data has been read. */
  while (true)
  {
    /* Do the actual read.
     * The return value contains the number of read samples. */
    rc = dds_read (reader, samples, infos, MAX_SAMPLES, MAX_SAMPLES);
    if (rc < 0)
      DDS_FATAL("dds_read: %s\n", dds_strretcode(-rc));

    /* Check if we read some data and it is valid. */
    if ((rc > 0) && (infos[0].valid_data))
    {
      /* Print Message. */
      msg = (HelloWorldData_Msg*) samples[0];
      printf ("=== [Subscriber] Received : ");
      printf ("Message (%"PRId32", %s)\n", msg->userID, msg->message);
      fflush (stdout);
      break;
    }
    else
    {
      /* Polling sleep. */
      dds_sleepfor (DDS_MSECS (20));
    }
  }

  /* Free the data location. */
  HelloWorldData_Msg_free (samples[0], DDS_FREE_ALL);

  /* Deleting the participant will delete all its children recursively as well. */
  rc = dds_delete (participant);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_delete: %s\n", dds_strretcode(-rc));

  return EXIT_SUCCESS;
}
```

* `publisher.c`와 동일하게 `dds.h`와 `HelloWorldData.h` 헤더를 선언한다.

```c
#include "dds/dds.h"
#include "HelloWorldData.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>
```

* `MAX_SAMPLES`는 메세지를 담을 사이즈의 크기를 정의한다.

```c
/* An array of one message (aka sample in dds terms) will be used. */
#define MAX_SAMPLES 1
```

* 다음으로 `participant`, `topic`, `reader`를 선언하고, `HelloWorldData_Msg` 타입의 `*msg`를 선언한다. 다음으로 `MAX_SAMPLES` 크기의 void형 `*samples`와, dds_sample_info_t 타입의 `infos`를 선언한다. dds 리턴 값을 저장하는 `rc`를 선언하고, dds의 데이터 송수신 품질을 정의하는 `qos`를 생성한다.

```c
int main (int argc, char ** argv)
{
  dds_entity_t participant;
  dds_entity_t topic;
  dds_entity_t reader;
  HelloWorldData_Msg *msg;
  void *samples[MAX_SAMPLES];
  dds_sample_info_t infos[MAX_SAMPLES];
  dds_return_t rc;
  dds_qos_t *qos;
  (void)argc;
  (void)argv;
```

* `publisher.c`와 동일하게 `participant`와 `topic`을 선언한다. 이 때 `topic`의 `dds_create_topic()`의 `"HelloWorldData_Msg"`는 publisher와 동일한 형태여야 한다. 

```c
  /* Create a Participant. */
  participant = dds_create_participant (DDS_DOMAIN_DEFAULT, NULL, NULL);
  if (participant < 0)
    DDS_FATAL("dds_create_participant: %s\n", dds_strretcode(-participant));

  /* Create a Topic. */
  topic = dds_create_topic (
    participant, &HelloWorldData_Msg_desc, "HelloWorldData_Msg", NULL, NULL);
  if (topic < 0)
    DDS_FATAL("dds_create_topic: %s\n", dds_strretcode(-topic));
```

* 다음으로 `reader`를 선언하는 부분인데, 그 이전에 `qos`를 먼저 정의한다. `dds_create_qod()`로 `qos`를 초기화 하고, `dds_qset_reliability()` 함수를 이용하여 `qos` 동작 방식을 설정한다.
* publisher에서는 `qos`를 설정하지 않았지만, 이와 동일한 방식으로 `qos`를 설정하여 `dds_create_writer()`에 넣을 수 있다.
* 마지막으로 `reader` 객체를 `dds_create_reader()`함수로 선언한다.

```c
  /* Create a reliable Reader. */
  qos = dds_create_qos ();
  dds_qset_reliability (qos, DDS_RELIABILITY_RELIABLE, DDS_SECS (10));
  reader = dds_create_reader (participant, topic, qos, NULL);
  if (reader < 0)
    DDS_FATAL("dds_create_reader: %s\n", dds_strretcode(-reader));
  dds_delete_qos(qos);
```

* `samples[0]`에 `HelloWorldData_Msg__alloc()`을 이용하여 해당 버퍼를 초기화한다.

```c
  printf ("\n=== [Subscriber] Waiting for a sample ...\n");
  fflush (stdout);

  /* Initialize sample buffer, by pointing the void pointer within
   * the buffer array to a valid sample memory location. */
  samples[0] = HelloWorldData_Msg__alloc ();
```

* `dds_read()`함수로 `"HelloWorldData_Msg"` 토픽의 메세지를 읽어온다.
* 메세지는 `samples[0]`에 저장되며, `(HelloWorldData_Msg*)` 형태로 msg를 저장할 수 있다.

```c
  /* Poll until data has been read. */
  while (true)
  {
    /* Do the actual read.
     * The return value contains the number of read samples. */
    rc = dds_read (reader, samples, infos, MAX_SAMPLES, MAX_SAMPLES);
    if (rc < 0)
      DDS_FATAL("dds_read: %s\n", dds_strretcode(-rc));

    /* Check if we read some data and it is valid. */
    if ((rc > 0) && (infos[0].valid_data))
    {
      /* Print Message. */
      msg = (HelloWorldData_Msg*) samples[0];
      printf ("=== [Subscriber] Received : ");
      printf ("Message (%"PRId32", %s)\n", msg->userID, msg->message);
      fflush (stdout);
      break;
    }
    else
    {
      /* Polling sleep. */
      dds_sleepfor (DDS_MSECS (20));
    }
  }
```

* dds 통신이 종료되면 초기화 했던 `samples[0]` 버퍼를 `HelloWorldData_Msg_free()`함수로 해제하고, `dds_delete()`함수로 `participant` 객체를 제거한다. 마지막으로 `EXIT_SUCCESS`를 리턴함으로써 코드를 종료한다.

```c
  /* Free the data location. */
  HelloWorldData_Msg_free (samples[0], DDS_FREE_ALL);

  /* Deleting the participant will delete all its children recursively as well. */
  rc = dds_delete (participant);
  if (rc != DDS_RETCODE_OK)
    DDS_FATAL("dds_delete: %s\n", dds_strretcode(-rc));

  return EXIT_SUCCESS;
}
```
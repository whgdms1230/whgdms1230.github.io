---
sort: 3
---

# Principle of C++ Design

* 참고문헌 : 전문가를 위한 C++(마크 그레고리 / 한빛미디어)

## 1. 추상화
추상화(abstraction)은 내부 구현과 외부 인터페이스를 분리하는 것이다. 내부 구현 방식을 이해하지 않아도 코드를 쉽게 사용할 수 있게 구성해야 한다.

간단한 예로 `<cmath>` 헤더 파일에 선언된 `sqrt()` 함수를 호출하는 경우에, 이 함수가 제곱근을 구하는 데 내부적으로 사용하는 알고리즘을 몰라도 된다. 실제로 제곱근 계산에 대한 내부 구현은 라이브러리 버전마다 달라질 수 있는데, 인터페이스만 그대로 유지된다면 기존에 이 함수를 호출한 코드는 버전 변화에 아무런 영향을 받지 않는다.

구체적인 예로 체스 프로그램을 만들기 위해 구현한 체스보드를 다음과 같이 2차원 포인터 배열로 구현한다.
```cpp
ChessPiece* chessBoard[8][8];
...
chessBoard[0][0] = new Rook();
```

하지만 이렇게 하면 체스보드를 사용하는 프로그래머가 항상 체스보드가 2차원 배열로 구현됐다는 사실을 알아야 하기 때문에 추상화 원칙에 어긋난다.
또한, 이러한 문제를 해결하기 위해 크기가 64인 1차원 vector로 변경하게 되는 경우에 문제가 된다. 프로그램 코드 전체를 뒤져서 체스보드를 사용한 부분을 일일이 수정해야 하기 때문이다. 또한 체스보드를 사용하는 측에서 메모리 조작 과정에 문제가 발생하지 않도록 직접 관리해야 한다.

이러한 문제를 해결하기 위해 체스보드 모델을 클래스로 작성해야 한다. 그런 다음 인터페이스를 공개하고 그 뒤에 구현에 대한 세부사항을 숨긴다.
```cpp
class ChessBoard
{
    public:
        // 생성자, 소멸자, 대입 연산자 생략
        void setPieceAt(size_t x, size_t y, ChessPiece* piece);
        ChessPiece* getPieceAt(size_t x, size_t y);
        bool isEmpty(size_t x, size_t y) const;
    private:
        // 데이너 멤버 코드 생략
};
```
이 인터페이스는 내부 구현에 대한 코드가 한 줄도 나오지 않았다. ChessBoard를 2차원 배열로 구현하더라도 인터페이스에 전혀 어긋나지 않는다. 구현 방식이 바뀌더라도 인터페이스를 그대로 유지할 수 있다. 게다가 구현 코드에서 기능을 추가로 제공할 수 있다.

## 2. 재사용
재사용(reuse)은 프로그래밍을 할 때 직접 구현할 필요가 없는 부분은 해당 기능을 제공하는 코드를 적절히 골라서 현재 프로그램에 재사용하는 것이다. 이러한 재사용 원칙은 직접 작성한 코드뿐만 아니라 가져다 쓰는 코드에도 똑같이 적용된다.

## 2.1 재사용 가능한 코드 만들기
프로그램을 작성할 때 클래스, 알고리즘, 데이터 구조를 재사용할 수 있도록 디자인해야 한다. 그래서 자신 뿐만 아니라 다른 동료도 현재 프로젝트나 향후 프로젝트에서 활용할 수 있어야 한다. 따라서 당장 주어진 문제에만 적용할 수 있도록 너무 특화된 형태로 디자인하지 않는 것이 좋다.

C++은 코드를 범용적으로 만들 수 있도록 **템플릿**이라는 기능을 제공한다. 다음 예제는 템플릿을 이용하여 데이터 구조를 만드는 예를 보여준다.
```cpp
template <typename PieceType>
class GameBoard
{
    public:
        // 생성자, 소멸자, 대입 연산자 생략
        void setPieceAt(size_t x, size_t y, PieceType* piece);
        PieceType* getPieceAt(size_t x, size_t y);
        bool isEmpty(size_t x, size_t y) const;
    private:
        // 데이너 멤버 코드 생략
}
```

앞선 예제처럼 ChessPiece를 저장하는 ChessBoard를 너무 구체적으로 작성하지 않고, 체스나 체커와 같이 2차원 보드를 사용하는 게임이라면 언제든지 적용할 수 있도록 GameBoard라는 제네릭 템플릿으로 정의하였다. 또한 게임에 사용할 말을 인터페이스에 고정시키지 말고 템플릿 매개변수로 전달하도록 클래스 선언을 변경하였다.

## 2.2 디자인 재사용
C++ 프로그래밍에 사용되는 프로그램 디자인 기법과 디자인 패턴을 최대한 활용하여 프로그래밍을 해야 한다. 이렇게 하려면 여러 가지 패턴과 기법을 잘 익혀둬야 한다. 그래야 주어진 디자인 문제에 어떤 해결책을 적용할지 판단할 수 있다.

## 2.3 코드의 재사용
재사용 할 수 있는 코드 유형은 다음과 같다.
* 예전에 자신이 작성했던 코드
* 동료가 작성한 코드
* 현재 소속 회사나 조직 외의 서드파티에서 작성한 코드

재사용할 코드를 만드는 형식도 다음과 같이 다양하다.
* 독립 함수 또는 클래스 : 자신 또는 동료가 작성한 코드의 대부분의 형태
* 라이브러리 : 특정한 작업을 처리하는 데 필요한 코드를 한데 묶은 것
* 프레임워크 : 디자인할 프로그램의 기반이 되는 코드를 모아둔 것

코드 재사용 여부는 주어진 상황과 목적에 따라 판단해야 한다. 직접 작성하는 데 걸리는 시간과 주어진 문제에 적절한 라이브러리를 찾아서 사용법을 익히는 데 걸리는 시간을 잘 비교해서 결정해야 하는 경우가 많다.

### 2.3.1 코드 재사용 전략
코드를 재사용하는 것이 적합한지, 어느 코드를 사용해야 할지는 상황에 맞게 결정해야 한다. 항상 장단점이 존재하기 때문에 다음과 같은 전략을 고려하여 재사용 여부 및 재사용 코드를 선정하는 것이 좋다.
1. 기능과 제약사항 파악하기
2. 성능 파악하기
3. 플랫폼 제약사항 파악하기
4. 라이선스와 기술 지원 파악하기
5. 도움을 받을 수 있는 곳 파악하기
6. 프로토타입
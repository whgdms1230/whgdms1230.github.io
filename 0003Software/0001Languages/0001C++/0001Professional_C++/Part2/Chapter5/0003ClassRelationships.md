---
sort: 3
---

# Class Relationships

* 참고문헌 : 전문가를 위한 C++(마크 그레고리 / 한빛미디어)

프로그래밍을 하다 보면 서로 다른 클래스가 공통적인 속성을 지니거나 최소 두 클래스가 서로 관련되는 경우가 있다. 객체지향 언어는 이러한 객체의 관계를 표현하기 위해 몇 가지 메커니즘을 지원한다.

객체 관계에는 크게 `has-a` 관계와 `is-a` 관계가 있다.

## 1. has-a

A는 B를 가진다 혹은 A에 B가 있다고 표현되는 객체 관계를 `has-a` 관계 또는 집합 관계라고 한다.

앞서 정의한 컴포넌트는 일반적으로 `has-a` 관계로 표현된다. 객체의 구성 요소를 표현하기 때문이다.

## 2. is-a

`is-a` 관계는 OOP의 핵심 개념 중 하나인 상속에 대한 것이다. 상속은 파생, 서브클래싱, 확장 등으로 다양하게 표현된다.

클래스는 현실세계가 여러 가지 속성과 동작을 가진 객체로 구성된다는 점을 모델링한 것이고, 상속은 이러한 객체가 주로 계층 구조로 이루어졌다는 점을 모델링한 것이다. 이러한 계층 구조가 바로 `is-a` 관계다.

클래스를 `is-a` 관계로 엮으려면 공통 기능을 베이스 클래스로 묶어서 다른 클래스가 확장할 수 있게 만들어야 한다. 여러 클래스의 코드가 상당 부분 겹치거나 완전히 똑같다면 그 부분을 상위 클래스로 묶어서 빼내는 게 좋다. 그래야 공통적인 부분에서 변경사항이 발생할 때 상위 클래스 한 곳에서만 고쳐도 다른 하위 클래스에 수정사항을 똑같이 반영할 수 있다.

### 2.1 상속 기법

다른 클래스를 상속한 파생 클래스를 부모 클래스(상위 클래스, 베이스 클래스, 슈퍼 클래스)와 구분하는 방법은 여러가지가 있으며, 그 중 한 개 혹은 여러 개의 기법을 조합해서 파생클래스를 만든다.

#### 2.1.1 기능 추가

파생 클래스는 기능을 더 추가해서 부모 클래스를 보완한다. 즉 부모 클래스에는 없는 파생 클래스만 가지는 메서드가 있다.

#### 2.1.2 기능 변경

파생 클래스는 부모 클래스가 가진 메서드를 변경하거나 무시(오버라이드)할 수 있다.
만약 베이스 클래스를 추상 클래스로 정의하면 이를 상속하는 모든 파생 클래스는 베이스 클래스에 구현되지 않은 메서드를 모두 구현해야 한다.

#### 2.1.3 프로퍼티 추가

베이스 클래스를 상속한 파생 클래스에 새로운 프로퍼티를 추가할 수도 있다.

#### 2.1.4 프로퍼티 변경

메서드를 오버라이드하는 것처럼 프로퍼티도 오버라이드할 수 있다. 하지만 베이스 클래스의 속성을 가리기 때문에 이렇게 하는 것이 바람직하지 않을 때가 많다.

> 은닉 : 베이스 클래스가 특정한 이름의 프로퍼티에 어떤 값을 가지고 있는 상태에서 파생 클래스가 그 프로퍼티와 같은 이름을 정의해서 다른 값을 표현하는 것

### 2.2 다형성과 코드 재사용

다형성(폴리모피즘)이란 프로퍼티와 메서드의 표준 셋으로 정해두면 그 형식에 맞는 객체라면 어느 것이든 서로 바꿔서 적용할 수 있다는 개념이다.

이는 베이스 클래스에 정의된 프로퍼티와 메서드를 파생 클래스에서 모두 제공되어야 하며, 이는 각각에 파생 클래스에서 동일한 메서드를 실행하는 것으로 같은 동작을 실행시킬 수 있다.

상속은 다형성 뿐만 아니라 코드를 재사용하는데도 활용된다. 단순히 기존에 작성한 코드를 재사용하기 위한 목적으로만 사용하는 것으로, 이미 만들어진 클래스를 가져와 부족한 기능을 추가하는 방식으로 활용하는 것이다.

## 3. not-a

두 클래스 관계 중 어느 것이 적합한지 따지기 전에 먼저 그런 관계가 성립할 수 있는지부터 살펴봐야 한다.

객체지향 방식으로 계층을 구성하려면 억지로 관계를 형성하지 말고 기능 관점에서 관계를 표현해야 한다. 불필요한 상속 관계를 만들지 않으려면 먼저 디자인 초안부터 그려보며, 모든 클래스와 파생 클래스마다 어떤 프로퍼티와 메서드를 넣으면 좋을지 적는다.

특별히 프로퍼티나 메서드를 갖지 않는 클래스가 있거나 추상 베이스 클래스가 아닌 클래스의 프로퍼티와 메서드를 다른 파생 클래스에서 모두 오버라이드한다면 디자인을 바꾸는 것이 좋다.

## 4. 클래스 계층

A 클래스가 B 클래스의 베이스 클래스가 될 수 있듯이 B 클래스도 C 클래스의 베이스 클래스가 될 수 있다. 객체지향 계층은 클래스 관계를 이렇게 여러 계층으로 표현한다.

제대로 구성된 객체지향 계층은 다음과 같은 특성을 갖는다.

* 기능적으로 의미 있는 관계에 따라 클래스를 구성한다.
* 공통 기능을 베이스 클래스로 뽑아냈기 때문에 코드를 재사용하기 쉽다.
* 부모가 추상클래스가 아닌 이상 부모의 기능을 과도하게 오버라이딩 하는 파생 클래스가 없다.

## 5. 다중 상속

단일 상속은 파생 클래스의 바로 위 부모 클래스가 하나인 경우이다. 반면 다중 상속은 베이스 클래스를 여러개 두는 것이다.

예를 들어, 사용자가 클릭할 수 있는 이미지로 사용자 인터페이스를 구현한다고 하자. 이러한 그림 버튼 객체는 버튼이기도 하고 이미지이기도 하다. 따라서 버튼 클래스와 이미지 클래스 모두 상속하도록 할 수 있다.

다중 상속이 꼭 필요할 때가 있긴 하지만 단점도 많기 때문에 사용할 때 각별히 주의해야 한다. 다중 상속을 싫어하는 개발자도 많은데, 반대하는 이유는 다음과 같다.

1. 다중 상속 관계는 시각적으로 표현하기 복잡하다. 부모 클래스가 여러 개라서 각 클래스의 관계를 명확히 파악하기 힘들다. 코드에서 이런 클래스를 많이 사용할수록 구조를 파악하는 것이 불가능해질 수 있다.
2. 다중 상속 때문에 구조의 명확성이 깨질 수 있다.
3. 다중 상속은 구현하기 힘들다.

## 6. 믹스인 클래스

믹스인(첨가) 클래스는 지금까지 소개한 것과 다른 종류의 클래스 관계를 표현한다.

믹스인 클래스는 '이 클래스가 할 수 있는 일이 또 뭐가 있나?'란 질문에 '~도 할 수 있다'라고 답하는 역할을 한다.

믹스인 클래스는 `is-a` 관계를 완전히 구현하지 않고도 기능을 추가할 때 사용한다. 일종의 공유 관계라고 볼 수 있다. 즉, 기존에 만든 계층을 깨드리지 않으면서, 기능을 추가하는 방법이다.
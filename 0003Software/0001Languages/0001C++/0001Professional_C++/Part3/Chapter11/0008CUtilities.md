---
sort: 8
---

# C Utilities

* 참고문헌 : 전문가를 위한 C++(마크 그레고리 / 한빛미디어)

## 1. 가변 길이 인수 리스트

C 언어의 기능인 가변 길이 인수 리스트는 간혹 레거시 코드에서 사용된다.

`<cstudio>`에서 제공하는 C 함수인 printf()를 예로 살펴보면, 이 함수를 호출할 때 전달할 수 있는 인수는 다음과 같이 다양하다.

```cpp
printf("int %d\n", 5);
printf("String %s and int %d\n", "hello", 5);
printf("Many ints: %d, %d, %d, %d, %d\n", 1, 2, 3, 4, 5);
```

C/C++는 가변 길이 인수를 가진 함수를 직접 정의하는 데 필요한 문법과 유틸리티 매크로를 제공한다.

예를 들어 디버그 플래그가 설정됐다면 `stderr`로 스트링을 출력하고, 그렇지 않으면 아무 일도 하지 않는 디버깅 함수를 구현한다고 하자. printf()처럼 이 함수도 인수의 개수와 타입을 임의로 지정할 수 있다면 편할 것이다.

```cpp
#include <cstdio>
#include <cstdarg>

bool debug = false;

void debugOut(const char* str, ...)
{
    va_list ap;
    if(debug){
        va_start(ap, str);
        vfprintf(stderr, str, ap);
        va_end(ap);
    }
}
```

debougOut() 프로토타입을 보면 이름과 타입이 지정된 str이라는 매개변수 뒤에 생략 부호 `...`이 있다. 이는 임의 개수와 타입의 인수를 받을 수 있다는 것을 의미한다. 이렇게 선언된 인수는 반드시 `<cstdarg>`에 정의된 매크로로 접근해야 한다.

va_list 타입의 변수를 선언한뒤 va_start를 호출해서 초기화했다. va_start()의 두 번째 매개변수는 반드시 매개변수 리스트의 이름 있는 변수 중에서 오른쪽 끝에 있는 것이어야 한다. 가변 길이 인수 리스트를 가진 함수라면 반드시 이름 있는 매개변수가 한 개 이상이어야 한다.

다음으로 `<cstdio>`에 있는 표준 함수인 vfprintf()로 전달한다. vfprintf()를 호출한 결과가 리턴되면 va_end()를 호출해서 가변 길이 인수 리스트에 대한 접근을 종료한다. va_start()를 호출했다면 반드시 이에 대응되는 va_end()를 호출해서 함수의 스택 상태를 일관성 있게 유지해야 한다.

```cpp
debug = true;
debugOut("int %d\n", 5);
debugOut("String %s and int %d\n", "hello", 5);
debugOut("Many ints: %d, %d, %d, %d, %d\n", 1, 2, 3, 4, 5);
```

### 1.1 인수에 접근하기

실제 인수에 직접 접근하고 싶다면 va_arg()를 사용한다. 이 매크로는 va_list와 이를 해석할 타입을 인수로 받는다. 하지만 아쉽게도 인수 리스트의 끝은 명시적으로 지정하지 않고서는 알아낼 방법이 없다.

예를 들어 첫 번째 매개변수를 매개변수 개수로 지정할 수 있다. 또는 포인터가 여러 개 있을 때 마지막 포인터를 nullptr로 지정하는 방법도 있다.

다음 코드는 함수를 호출한 측에서 이름 있는 매개변수 중 첫 번째 매개변수로 인수 개수를 지정할 수 있게 구현하는 예를 보여주고 있다. 이 함수는 임의 개수의 int 값을 받아서 출력한다.

```cpp
void printInts(size_t num, ...)
{
    int temp;
    va_list ap;

    va_start(ap, num);
    for(size_t i = 0; i < num; ++i){
        temp = va_arg(ap, int);
        cout << temp << " ";
    }
    va_end(ap);
    cout << endl;
}
```

printInts()의 호출방법은 다음과 같다. 이 문장을 보면 첫 번째 매개변수는 뒤에 나올 정수 인수 개수를 지정한다.

```cpp
printInts(5, 5, 4, 3, 2, 1);
```

### 1.2 C 스타일 가변 길이 인수 리스트를 사용하면 안 되는 이유
C 스타일 가변 길이 인수 리스트는 그리 안전하지 않다. printInts() 함수 예제에서 알 수 있듯이 다음과 같은 문제가 있다.

* 매개변수 개수를 알 수 없다.
* 인수 타입을 알 수 없다. va_arg() 매크로는 전달된 타입을 이용하여 현재 시점의 값을 해석한다. 그런데 va_arg()를 통해 얼마든지 그 값이 다른 타입으로 해석될 수도 있다. 따라서 타입이 정확한지 검증할 방법이 없다.

## 2. 전처리 매크로

C++ 전처리기로 간단한 함수 형태의 매크로를 정의할 수 있다.

```cpp
#define SQUARE(x) ((x) * (x)) // 매크로 뒤에는 세미콜론을 붙이지 않는다.

int main()
{
    cout << SQUARE(5) << endl;
    return 0;
}
```

매크로는 C 언어에서 물려받은 기능으로, 타입 검사를 하지 않고 이를 호출한 모든 부분을 전처리기가 텍스트 바꾸기를 하듯 교체한다는 점을 제외하면 inline 함수와 비슷하다. 이때 전처리기는 실제 함수 호출 메커니즘을 적용하지 않는다. 그래서 의도하지 않는 결과가 발생할 수도 있다.

예를 들어 다음과 같이 QUARE 매크로에 5가 아닌 2+3 이란 인수를 지정하는 경우를 생각해보자.

```cpp
cout << SQUARE(2 + 3) << endl;
```

SQUARE의 계산 결과로 25가 나올 것이다. 그런데 만약 SQUARE 매크로 정의에서 소괄호가 없는 경우에는 위 결과가 11이 나올 것이다.

```cpp
#define SQUARE(x) (x * x)
```

그 이유는 매크로는 함수 호출 매커니즘이 아닌 단순 텍스트 바꾸기의 기능을 수행하기 때문이다. 따라서 소괄호가 없는 매크로를 사용한 앞의 문장은 다음 문장과 같기 때문에 11이 나오는 것이다.

```cpp
cout << (2 + 3 * 2 + 3) << endl;
```

매크로를 잘못 사용하면 성능에 지장을 줄 수 있다. 예를 들어 SQUARE를 다음과 같이 호출한 경우를 보자.

```cpp
cout << SQUARE(veryExpensiveFunctionCallToComputeNumber()) << endl;
```

전처리기는 이 문장을 다음과 같이 바꾼다.

```cpp
cout << ((veryExpensiveFunctionCallToComputeNumber()) * (veryExpensiveFunctionCallToComputeNumber())) << endl;
```

그러면 굉장히 오래 걸리는 함수를 두 번이나 호출하게 된다. 이는 매크로를 사용하면 안 되는 또 다른 이유다.

매크로는 디버깅할 때도 문제가 된다. 전처리기는 찾아서 바꾸는 방식으로 처리하기 때문에 프로그래머가 볼 때와 컴파일러나 디버거가 볼 때 코드 형태가 서로 다르다. 그래서 매크로 대신 인라인 함수를 사용하는 것이 바람직하다.
---
sort: 1
---

# References

* 참고문헌 : 전문가를 위한 C++(마크 그레고리 / 한빛미디어)

## 1. 레퍼런스 변수

레퍼런스 변수는 반드시 생성하자마자 초기화해야 한다.

```cpp
int x = 3;
int& xRef = x;
```

xRef는 x의 또 다른 이름이다. xRef를 사용하는 것은 x를 사용하는 것과 같다.

정수 리터럴처럼 이름 없는 값에 대해서는 레퍼런스를 생성할 수 없다. 단, const 값에 대해서는 레퍼런스를 생성할 수 있다.

```cpp
int& unnamedRef1 = 5; // 컴파일 에러 발생
const int& unnamedRef2 = 5; // 정상 작동
```

상수가 non-const 레퍼런스이기 때문에 unnamedRef1에 상수 5를 대입하는 문장에서 컴파일 에러가 발생한다. 반면 unnamedRef2는 const 레퍼런스로 선언했기 때문에 문제가 없다.

임시 객체도 마찬가지로, non-const 레퍼런스는 만들 수 없지만 const 레퍼런스는 만들 수 있다.

```cpp
std::string getString() { return "Hello world!"; }
```

getString()을 호출한 결과를 const 레퍼런스에는 담을 수 있다. 그러면 이 레퍼런스가 스코프를 벗어나기 전까지 std::string 객체를 계속 가리킬 수 있다.

```cpp
std::string& string1 = getString(); // 컴파일 에러 발생
const std::string& string2 = getString(); // 정상 작동
```

### 1.1 레퍼런스 대상 변경하기

레퍼런스는 처음 초기화할 때 지정한 변수만 가리킬 수 있다. 한 번 선언된 레퍼런스에 다른 변수를 대입하면 레퍼런스가 가리키는 대상이 바뀌는 것이 아니라 레퍼런스가 원래 가리키던 변수의 값이 바뀌게 된다.

```cpp
int x = 3, y = 4;
int& xRef = x;
xRef = y;   // xRef가 y를 가리키는 것이 아니라 x의 값을 4로 변경한다.
```

만약 y의 주소를 대입하는 경우에는 컴파일 에러가 발생한다. y의 주소는 포인터지만 xRef는 포인터에 대한 레퍼런스가 아닌 int에 대한 레퍼런스이기 때문이다.

또한 레퍼런스에 레퍼런스를 대입하는 방식으로도 레퍼런스가 가리키는 대상을 바꿀 수 없다.

```cpp
int x = 3, z = 5;
int& xRef = x;
int& zRef = z;
zRef = xRef;    // 레퍼런스가 아닌 값이 대입된다. z = 3
```

### 1.2 포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터

레퍼런스는 모든 타입에 대해 만들 수 있으며, 포인터 타입을 가리키는 레퍼런스도 만들 수 있다.

```cpp
int* intP;
int*& ptrRef = intP;
ptrRef = new int;
*ptrRef = 5;
```

ptrRef는 intP에 대한 레퍼런스고, intP는 int에 대한 포인터다. ptrRef를 수정하면 intP가 바뀐다. 레퍼런스가 가져온 주소는 그 레퍼런스가 가리키는 변수의 주소와 같다.

```cpp
int x = 3;
int& xRef = x;
int* xPtr = &xRef; // 레퍼런스의 주소는 값에 대한 포인터와 같다.
*xPtr = 100;
```

이 코드는 x에 대한 레퍼런스 xRef의 주소를 가져와서 xPtr가 x를 가리키도록 설정한다. *xPtr에 100을 대입하면 x의 값이 100으로 바뀐다.

`xPtr == xRef`이라는 비교 연산을 수행하면 서로 타입이 다르다는 컴파일 에러가 발생한다.xPtr는 int에 대한 포인터 타입이고, xRef는 int에 대한 레퍼런스 타입이기 때문이다. 따라서 `xPtr == &xRef`나 `xPtr == &x`와 같이 작성해야 한다.

> 레퍼런스에 대한 레퍼런스는 선언할 수 없다. 예를 들어 `int& &`나 `int&*`과 같이 선언할 수 없다.

## 2. 레퍼런스 데이터 멤버

클래스의 데이터 멤버를 레퍼런스 타입으로 정의할 수 있다. 레퍼런스 데이터 멤버는 반드시 생성자의 본문이 아닌 ㄴ생성자 이니셜라이저에서 초기화해야 한다.

```cpp
class MyClass
{
    public:
        MyClass(int& ref) : mRef(ref) {}

    private:
        int& mRef;
};
```

## 3. 레퍼런스 매개변수

레퍼런스는 주로 함수나 메서드의 매개변수로 많이 사용한다. 매개변수를 레퍼런스 타입으로 선언하면 인수를 레퍼런스 전달 방식으로 처리한다. 따라서 전달된 값을 수정하면 인수로 지정한 원본 변수의 값도 바뀐다.

```cpp
void swap(int& first, int& second)
{
    int temp = first;
    first = second;
    second = temp;
}

int x = 5, y = 6;
swap(x, y); // 두 개의 값이 맞바뀜.
```

단, 일반 레퍼런스 변수를 상수로 초기화할 수 없듯이 non-const 레퍼런스 전달 방식을 사용하는 함수의 인수로 상수를 전달할 수 없다.

```cpp
swap(3, 4); // 컴파일 에러
```

> const 레퍼런스 전달 방식이나 rvalue 레퍼런스 전달 방식을 적용하면 함수에 상수 인수를 전달할 수 있다.

### 3.1 포인터를 레퍼런스로 전달하기

포인터를 역참조해서 전달하면 포인터를 레퍼런스로 변환할 수 있다. 포인터가 가리키는 값을 가져와서 레퍼런스 매개변수를 초기화하기 때문이다. 예를 들어 swap()을 호출할 때 포인터를 전달하려면 다음과 같이 작성해야한다.

```cpp
int x = 5, y = 6;
int *xp = &x, *yp = &y;
swap(*xp, *yp);
```

### 3.2 레퍼런스 전달 방식과 값 전달 방식

레퍼런스 전달 방식은 인수로 전달하면 그 결과가 원본 변수에 반영되게 만들고 싶을 때 주로 사용한다.

또한 레퍼런스로 전달하면 인수에 대한 복제본을 만들지 않기 때문에 다음과 같은 두 가지 장점이 있다.

1. 효율성 : 크기가 큰 객체나 struct는 복제 오버헤드가 크다. 레퍼런스 전달 방식을 사용하면 객체나 struct에 대한 레퍼런스만 함수에 전달한다.
2. 정확성 : 값 전달 방식을 지원하지 않는 객체가 있다. 지원하더라도 깊은 복제가 적용되지 않을 수 있다. 동적 할당 메모리를 사용하는 객체에 대해서는 반드시 커스텀 복제 생성자와 복제 대입 연산자를 정의해서 깊은 복제를 제공해야 한다.

이런 장점을 최대한 활용하고 원본 객체는 수정할 수 없게 만드려면 매개변수를 const 레퍼런스로 선언하면 된다.

## 4. 레퍼런스 리턴값

함수나 메서드의 리턴값도 레퍼런스 타입으로 지정할 수 있다. 객체 전체를 리턴하지 않고 객체에 대한 레퍼런스만 리턴하면 복제 연산을 줄일 수 있다. 물론 함수 종료 후에도 계속 남아 있는 객체에 대해서만 이렇게 레퍼런스로 리턴할 수 있다.

> 이동 의미론을 지원하는 함수는 값으로 리턴해도 레퍼런스로 리턴하는 것만큼 효율적으로 처리한다.

> 리턴값을 대입문의 왼쪽에 나오는 lvalue에 직접 대입할 때도 레퍼런스로 리턴한다.

## 5. rvalue 레퍼런스
lvalue는 변수처럼 이름과 주소를 가지면서 대입문의 왼쪽에 나온다. rvalue는 lvalue가 아닌 나머지를 말한다. rvalue의 대표적인 예로 상숫값과 임시 객체가 있다.

[우측값 레퍼런스 참조](/0003Software/0001Languages/0001C++/0001Professional_C++/Part3/Chapter9/0002DynamicAllocation.html#41-우측값-레퍼런스)

다음 예시는 매개변수를 lvalue 레퍼런스로 정의했다. 

```cpp
// 매개변수를 lvalue 레퍼런스로 정의함
void handleMessage(std::string& message)
{
    cout << "handleMessage with lvalue reference: " << message<< endl;
}
```

하지만 위와같이 lvaule 레퍼런스로 정의하면 다음과 같이 호출할 수 없다.

```cpp
handleMessage("Hello World"); // 리터럴은 lvalue가 아니다.

std::string a = "Hello ";
std::string b = "World";
handleMessage(a + b); // 임시값은 lvalue가 아니다.
```

위와 같이 호출하려면 rvalue 레퍼런스를 받는 버전을 구현해야 한다.

```cpp
// 매개변수를 rvalue 레퍼런스로 정의함
void handleMessage(std::string&& message)
{
    cout << "handleMessage with rvalue reference: " << message<< endl;
}
```

## 6. 레퍼런스와 포인터의 선택 기준

##### 레퍼런스의 안정성

레퍼런스를 사용하면 코드를 깔끔하고 읽기 쉽게 작성할 수 있다. 게다가 포인터보다 훨씬 안전하다. 레퍼런스의 값은 널이 될 수 없고, 레퍼런스를 명시적으로 역참조할 수도 없다. 그래서 포인터처럼 역참조 과정에서 에러가 발생할 가능성도 없다.

##### 포인터를 사용해야하는 경우

단, 포인터가 하나도 없을 때만 레퍼런스가 더 안전하다고 말할 수 있다. 예를들어 다음과 같이 임의의 메모리를 가리키도록 초기화한 포인터를 역참조해서 refcall()의 레퍼런스 타입 인수로 전달하면, 컴파일 에러는 발생하지 않지만 실행 과정에서 어떻게 동작할지 예측할 수 없다.

```cpp
void refcall(int& t) { ++t; }

int* ptr = (int*)8;
refcall(*ptr);
```

포인터를 사용한 코드는 거의 대부분 레퍼런스로 표현할 수 있다. 심지어 객체에 대한 레퍼런스는 객체에 대한 포인터처럼 다형성도 지원한다.

하지만 반드시 포인터를 사용해야 하는 경우가 있다. 대표적인 예로 가리키는 위치를 변경해야 할 때가 있다. 예를 들어 동적 할당 메모리의 주소는 레퍼런스가 아닌 포인터에 저장해야 한다. 또 다른 예로 주솟값이 nullptr가 될 수 있는 optional 타입은 반드시 포인터를 사용해야 한다. 또한 컨테이너에 다형성 타입을 저장할 때도 포인터를 사용해야 한다.

##### 메모리의 소유권으로 판단

매개변수나 리턴값을 포인터와 레퍼런스 중 어느 것으로 표현하는 것이 적합한지 판단하는 한 가지 방법은 메모리의 소유권이 어디에 있는지 따져보는 것이다. 

메모리의 소유권이 변수를 받는 코드에 있으면 객체에 대한 메모리를 해제하는 책임은 그 코드에 있다. 따라서 객체를 포인터(스마트 포인터)로 표현한다. 반면 메모리 소유권이 변수를 받는 코드에 없어서 메모리를 해제할 일이 없다면 레퍼런스로 전달한다.
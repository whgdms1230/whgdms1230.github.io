---
sort: 1
---

# References

* 참고문헌 : 전문가를 위한 C++(마크 그레고리 / 한빛미디어)

## 1. 레퍼런스 변수

레퍼런스 변수는 반드시 생성하자마자 초기화해야 한다.

```cpp
int x = 3;
int& xRef = x;
```

xRef는 x의 또 다른 이름이다. xRef를 사용하는 것은 x를 사용하는 것과 같다.

정수 리터럴처럼 이름 없는 값에 대해서는 레퍼런스를 생성할 수 없다. 단, const 값에 대해서는 레퍼런스를 생성할 수 있다.

```cpp
int& unnamedRef1 = 5; // 컴파일 에러 발생
const int& unnamedRef2 = 5; // 정상 작동
```

상수가 non-const 레퍼런스이기 때문에 unnamedRef1에 상수 5를 대입하는 문장에서 컴파일 에러가 발생한다. 반면 unnamedRef2는 const 레퍼런스로 선언했기 때문에 문제가 없다.

임시 객체도 마찬가지로, non-const 레퍼런스는 만들 수 없지만 const 레퍼런스는 만들 수 있다.

```cpp
std::string getString() { return "Hello world!"; }
```

getString()을 호출한 결과를 const 레퍼런스에는 담을 수 있다. 그러면 이 레퍼런스가 스코프를 벗어나기 전까지 std::string 객체를 계속 가리킬 수 있다.

```cpp
std::string& string1 = getString(); // 컴파일 에러 발생
const std::string& string2 = getString(); // 정상 작동
```

### 1.1 레퍼런스 대상 변경하기

레퍼런스는 처음 초기화할 때 지정한 변수만 가리킬 수 있다. 한 번 선언된 레퍼런스에 다른 변수를 대입하면 레퍼런스가 가리키는 대상이 바뀌는 것이 아니라 레퍼런스가 원래 가리키던 변수의 값이 바뀌게 된다.

```cpp
int x = 3, y = 4;
int& xRef = x;
xRef = y;   // xRef가 y를 가리키는 것이 아니라 x의 값을 4로 변경한다.
```

만약 y의 주소를 대입하는 경우에는 컴파일 에러가 발생한다. y의 주소는 포인터지만 xRef는 포인터에 대한 레퍼런스가 아닌 int에 대한 레퍼런스이기 때문이다.

또한 레퍼런스에 레퍼런스를 대입하는 방식으로도 레퍼런스가 가리키는 대상을 바꿀 수 없다.

```cpp
int x = 3, z = 5;
int& xRef = x;
int& zRef = z;
zRef = xRef;    // 레퍼런스가 아닌 값이 대입된다. z = 3
```

### 1.2 포인터에 대한 레퍼런스와 레퍼런스에 대한 포인터

레퍼런스는 모든 타입에 대해 만들 수 있으며, 포인터 타입을 가리키는 레퍼런스도 만들 수 있다.

```cpp
int* intP;
int*& ptrRef = intP;
ptrRef = new int;
*ptrRef = 5;
```

ptrRef는 intP에 대한 레퍼런스고, intP는 int에 대한 포인터다. ptrRef를 수정하면 intP가 바뀐다. 레퍼런스가 가져온 주소는 그 레퍼런스가 가리키는 변수의 주소와 같다.

```cpp
int x = 3;
int& xRef = x;
int* xPtr = &xRef; // 레퍼런스의 주소는 값에 대한 포인터와 같다.
*xPtr = 100;
```

이 코드는 x에 대한 레퍼런스 xRef의 주소를 가져와서 xPtr가 x를 가리키도록 설정한다. *xPtr에 100을 대입하면 x의 값이 100으로 바뀐다.

`xPtr == xRef`이라는 비교 연산을 수행하면 서로 타입이 다르다는 컴파일 에러가 발생한다.xPtr는 int에 대한 포인터 타입이고, xRef는 int에 대한 레퍼런스 타입이기 때문이다. 따라서 `xPtr == &xRef`나 `xPtr == &x`와 같이 작성해야 한다.

> 레퍼런스에 대한 레퍼런스는 선언할 수 없다. 예를 들어 `int& &`나 `int&*`과 같이 선언할 수 없다.

## 2. 레퍼런스 데이터 멤버

클래스의 데이터 멤버를 레퍼런스 타입으로 정의할 수 있다. 레퍼런스 데이터 멤버는 반드시 생성자의 본문이 아닌 ㄴ생성자 이니셜라이저에서 초기화해야 한다.

```cpp
class MyClass
{
    public:
        MyClass(int& ref) : mRef(ref) {}

    private:
        int& mRef;
};
```

## 3. 레퍼런스 매개변수

레퍼런스는 주로 함수나 메서드의 매개변수로 많이 사용한다. 매개변수를 레퍼런스 타입으로 선언하면 인수를 레퍼런스 전달 방식으로 처리한다. 따라서 전달된 값을 수정하면 인수로 지정한 원본 변수의 값도 바뀐다.

```cpp
void swap(int& first, int& second)
{
    int temp = first;
    first = second;
    second = temp;
}

int x = 5, y = 6;
swap(x, y); // 두 개의 값이 맞바뀜.
```

단, 일반 레퍼런스 변수를 상수로 초기화할 수 없듯이 non-const 레퍼런스 전달 방식을 사용하는 함수의 인수로 상수를 전달할 수 없다.

```cpp
swap(3, 4); // 컴파일 에러
```

> const 레퍼런스 전달 방식이나 rvalue 레퍼런스 전달 방식을 적용하면 함수에 상수 인수를 전달할 수 있다.

### 3.1 포인터를 레퍼런스로 전달하기

포인터를 역참조해서 전달하면 포인터를 레퍼런스로 변환할 수 있다. 포인터가 가리키는 값을 가져와서 레퍼런스 매개변수를 초기화하기 때문이다. 예를 들어 swap()을 호출할 때 포인터를 전달하려면 다음과 같이 작성해야한다.

```cpp
int x = 5, y = 6;
int *xp = &x, *yp = &y;
swap(*xp, *yp);
```


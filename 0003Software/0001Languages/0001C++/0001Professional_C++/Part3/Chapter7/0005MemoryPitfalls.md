---
sort: 5
---

# Common Memory Pitfalls

* 참고문헌 : 전문가를 위한 C++(마크 그레고리 / 한빛미디어)

## 1. 스트링 과소 할당 문제
C 스타일 스트링에서 가장 흔히 발생하는 문제는 과소 할당이다. 이 문제는 주로 프로그래머가 스트링의 끝을 나타내는 널문자(`'\0'`)가 들어갈 공간을 빼먹고 공간을 할당할 때 발생한다.

또한 프로그래머가 스트링의 최대 크기를 특정한 값으로 미리 정해둘 때도 발생한다. 

과소 할당 문제에 대한 예를 들면 다음과 같다.
> 네트워크에서 읽은 데이터를 C 스타일 스트링에 반복문을 이용하여 저장한다. 네트워크를 통해 한 번에 받을 수 있는 데이터 양이 제한돼 있기 때문이다. 루프를 한 번 돌 때마다 `getMoreData()`를 호출한다. 이 함수는 동적으로 할당한 메모리에 대한 포인터를 리턴한다. 데이터를 다 받았다면 `getMoreData()`는 nullptr를 리턴한다. C 함수인 `strcat()`은 C 스타일 스트링 인수 두 개를 받아서 첫 번째 스트링 뒤에 두 번째 스트링을 이어붙인다. 이 과정에서 버퍼의 크기가 결과로 나올 스트링의 크기보다 커야 한다.

```cpp
char buffer[1024] = {0}; // 버퍼 공간 확보
while (true) {
    char* nextChunk = getMoreData();
    if (nextChunk == nullptr) {
        break;
    } else {
        strcat(buffer, nextChunk); // 버그 발생, 버퍼 공간이 넘칠 수 있음.
        delete [] nextChunk;
    }
}
```

과소 할당 문제를 해결하는 방법은 세 가지로, 가장 바람직한 방법 순으로 나열한다.
1. C++ 스타일 스트링을 사용한다.
2. 버퍼를 전역 변수나 스택 변수로 만들지 말고 힙 공간에 할당한다.
3. 최대 문자 수를 입력받아서 그 길이를 넘어선 부분은 리턴하지 않고, 현재 버퍼에 남은 공간과 현재 위치를 항상 추적한다.

## 2. 메모리 경계 침범
포인터는 단지 메모리 주소이며, 메모리에서 아무 곳이나 가리킬 수 있다. 그런데 아무 곳이나 가리키는 상황이 발생하게 되면 문제가 된다.

예를 들어 스트링의 끝을 표현하는 `'\0'` 문자가 사라지게 된 경우, 다음과 같은 함수를 호출하면, 루프 종료 조건을 만족하지 못하여 스트링에 할당된 공간을 넘어서 `m`으로 채우게 된다. 결국 메모리의 중요한 영역까지 덮어씌워지면 프로그램이 죽을 수도 있다.

```cpp
void fillWithM(char* inStr)
{
    int i = 0;
    while (inStr[i] != '\0') {
        inStr[i] = 'm';
        i++;
    }
}
```

이러한 문제가 스트링이 아닌 배열에 발생하는 것을 흔히 버퍼 오버플로 에러라 부른다.

현재 나와 있는 메모리 검사 도구는 버퍼 오버플로 문제를 찾아준다. 또한 string이나 vector와 같은 C++의 고급 기능을 활용하면 C 스타일의 스트링이나 배열을 사용할 때 흔히 발생하는 버그를 방지할 수 있다.

## 3. 메모리 누수
메모리 누수 문제는 C/C++ 프로그래밍 과정에서 발견하거나 해결하기 가장 힘든 작업으로 손꼽힌다. 메모리 누수를 막기 위해 가장 먼저 스마트 포인터를 도입하는 것이 좋다.

메모리 누수 현상은 할당했던 메모리를 제대로 해제하지 않을 때 발생한다. 특히 객체를 가리키고 있던 포인터를 놓치게 되면 그 객체를 삭제할 방법이 없어지기 때문에 메모리 누수가 발생하기 쉽다.

## 4. 중복 삭제와 잘못된 포인터
delete로 포인터에 할당된 메모리를 해제하면 그 메모리를 프로그램의 다른 부분에서 사용할 수 있다. 하지만 그 포인터를 계속 쓰는 것을 막을 수는 없다. 이를 댕글링 포인터(dangling pointer)라 부른다. 이때 중복 삭제하면 문제가 발생한다. 한 포인터에 delete를 두 번 적용하면 이미 다른 객체를 할당한 메모리를 해제해버리기 때문이다.

이러한 문제점들은 가능한 C++의 string 클래스, vector 컨테이너, 스마트 포인터처럼 메모리를 자동으로 관리하는 객체를 사용하면 해결할 수 있다.
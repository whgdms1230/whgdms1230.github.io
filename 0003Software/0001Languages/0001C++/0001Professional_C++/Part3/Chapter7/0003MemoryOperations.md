---
sort: 3
---

# Low-Level Memory Operations

* 참고문헌 : 전문가를 위한 C++(마크 그레고리 / 한빛미디어)

C++의 장점 중 하나는 메모리에 신경을 덜 쓸 수 있다는 것이다. 메모리 관리 작업을 클래스 단위로 수행하면, 나머지 작업은 컴파일러가 도와주기 때문에, 사용성이 크게 높아진다.

하지만 특정 애플리케이션이나 레거시 코드에서 메모리를 로우레벨로 다뤄야 할 때가 있다. 이런 경우 메모리를 저수준으로 관리하는 방법에 대해 정리한다.

## 1. 포인터 연산

C++ 컴파일러는 포인터 연산을 수행할 때 포인터에 선언된 타입을 이용한다. 포인터를 int로 선언하고 그 값을 1만큼 증가시키면 포인터는 메모리에 한 바이트가 아닌 int 크기만큼 이동한다. 이 연산은 주로 배열을 다루는 데 유용하다.

```cpp
int* myArray = new int[8];
```

이 배열의 인덱스 2에 값을 넣는 방법은 다음과 같다.

```cpp
myArray[2] = 33;
```

이를 포인터 연산으로 표현하면 다음과 같다.

```cpp
*(myArray + 2) = 33;
```

포인터 연산의 강점은 myArray + 2 와 같은 표현식으로 포인터를 표현하고, 이를 이용해서 더 작은 정수 배열을 표현할 수 있다는 데 있다.

또한 포인터 연산에서 뺄셈도 유용하다. 한 포인터에서 같은 타입의 포인터를 빼면 두 포인터 사이에 몇 바이트가 있는지가 아니라 포인터에 지정한 타입의 원소가 몇 개 있는지 알 수 있다.

## 2. 커스텀 메모리 관리
리소스가 부족하거나 메모리 관리와 같은 특수한 작업을 수행할 때는 메모리를 직접 다뤄야 할 수도 있다. 주요 핵심은 클래스에 큰 덩어리의 메모리를 할당해놓고 필요할 때마다 잘라 쓰는 데 있다.

## 3. 가비지 컬렉션
가비지 컬렉션은 메모리를 정상 상태로 유지하기 위한 최후의 보루이다. 가비지 컬렉션을 제공하는 환경이라면 프로그래머가 객체에 할당된 메모리를 직접 해제할 일은 거의 없다. 더 이상 참조하지 않는 객체는 런타임 라이브러리에 의해 일정한 시점에 자동으로 해제된다.

C++는 자바다 C#과 달리 가비지 컬렉션이 기본으로 제공되지 않는다. 가비지 컬렉션을 구현하는 기법 중에 표시 후 쓸기(mark and sweep)란 알고리즘이 있다. 이 방식은 가비지 컬렉터가 프로그램에 있는 모든 포인터를 주기적으로 검사한 뒤 여기서 참조하는 메모리를 계속 사용하고 있는지 여부를 표시한다. 한 주기가 끝날 시점에 아무런 표시가 되지 않은 메모리는 더 이상 사용하지 않는 것으로 간주하고 해제한다.

C++에서 표시 후 쓸기 알고리즘을 다음과 같은 방식으로 구현할 수 있다.

1. 모든 포인터를 쉽게 탐색하도록 포인터를 가비지 컬렉터에 리스트 형태로 등록한다.
2. 가비지 컬렉터가 객체의 사용 상태를 표시할 수 있도록 모든 객체가 GarbageCollectible과 같은 믹스인 클래스를 상속하게 만든다.
3. 객체에 동시에 접근하지 못하도록 가비지 컬렉터가 작동하는 동안 포인터를 변경할 수 없게 한다.

가비지 컬렉터의 단점은 다음과 같다.

1. 가비지 컬렉터가 작동하는 동안 프로그램이 멈출 수 있다.
2. 가비지 컬렉터가 있으면 소멸자가 비결정적으로 호출된다. 객체는 가비지 컬렉터에서 처리하기 전에는 제거되지 않기 때문에 객체가 스코프를 벗어나더라도 소멸자가 즉시 실행되지 않는다.

가비지 컬렉션 메커니즘을 구현하기란 상당히 어렵다. 잘못 구현하기도 쉽고 에러도 많이 발생할 것이다.

C++에서는 스마트 포인터를 이용하여 가비지 컬렉션과 비슷한 방식으로 메모리를 관리할 수 있게 제공한다.

## 4. 객체 풀
객체 풀은 타입이 같은 여러 개의 객체를 지속적으로 사용해야 하지만 매번 객체를 생성하면 오버헤드가 상당히 커지는 상황에 적용하기 좋다.
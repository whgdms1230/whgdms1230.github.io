---
sort: 220317
---

# [C++] std::move()

## std::move()

* 출처: [발아 바라 프로그래밍 [C++] move 함수 이해하기 - 기초](https://pppgod.tistory.com/7)

##### Move semantics
move semantics은 이동 의미론이라고 불린다. 객체를 사용하는 예제를 보자.

```cpp
Object b = new Object();
Object a = b; // Object b(a)
```

a = b에서 우리가 원하는 결과는 b를 a로 복사하는 것이다. 실제로도 a는 b를 깊은복사(주소값도 독립적인 복사)를 통해 복사할 것이다. 그런데 b는 10(a = 10에서의 10)과 다르게 사라지지 않는다. b는 변수로 선언되었기 때문이다. 

그런데 만약 b가 3번째 줄 이후에 사용되지 않고, 2번째 줄에서 자기 역할이 다 끝났다고 생각해보자. 그렇다면 굳이 a가 비용이 비싼 b를 깊은 복사할 필요가 있을까?

이런 경우에 a가 b를 복사하지 않고 b를 소유한다고 생각해보자. 이때의 장점은 다음과 같다.

* b를 소멸 시킬 필요가 없다.
* a에 새로 메모리를 할당하지 않아도 된다.
* 생성자를 다시 호출하지 않아도 된다. 낭비되는 메모리와 시간을 줄일 수 있다.

이렇게 소유권을 이동시키는 경우 많은 장점들이 있다. 이처럼 소유권을 이동시키는 것을 **Move semantics** 라고 한다.

##### move()

위에서 이야기한 소유권을 이동시켜주는 함수가 move() 함수이다. 컴파일러에게 이 객체는 오른값이야라고 알려주는 것이다. 사용법은 다음과 같다.

```cpp
Object b = new Object();
Object a = move(b);
```

위와 같이 사용하게 되면 b의 소유권은 a로 전달된다. a는 b를 가져왔기 때문에 생성자를 호출할 필요도 없고 b는 소멸자를 호출할 필요도 없다. 대신 구현에 따라 다르겠지만 일반적으로 이동생성자가 호출된다. (move를 사용하지 않으면 복사생성자를 호출할 것이다)


## unique_ptr과 shared_ptr 객체의 std::move()

unique_ptr 객체는 move() 멤버 함수를 통해 소유권을 이전할 수는 있지만, 복사할 수는 없다. 소유권이 이전되면, 이전 unique_ptr 인스턴스는 더는 해당 객체를 소유하지 않게 재설정된다.

* 출처: [무민은귀여워](https://cutemoomin.tistory.com/entry/스마트-포인터-uniqueptr-sharedptr-weakptr)

하지만 shared_ptr의 경우 std::move()를 사용할 필요가 없다.

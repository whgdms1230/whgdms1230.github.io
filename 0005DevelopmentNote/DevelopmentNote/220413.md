---
sort: 220413
---

# 라이브러리

출처
* [Gidhub - 동적 라이브러리와 정적 라이브러리](https://goodgid.github.io/Static-VS-Dynamic-Libray/)
* [해시넷 - 라이브러리](http://wiki.hash.kr/index.php/%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC)

## 라이브러리란

* 라이브러리(영어: library)는 소프트웨어를 만들 때 쓰이는 클래스나 서브루틴들의 모임을 가리키는 말이다.
* 라이브러리(library)는 다른 프로그램들과 링크되기 위하여 존재하는, 하나 이상의 서브루틴(subroutine)이나 함수(function)들의 집합 파일이다.
* 링크(link)될 수 있도록 보통 컴파일된 형태인 목적 코드(object code)형태로 존재한다.
* 미리 컴파일 되어 있어서 컴파일 시간도 단축된다.

소스코드를 작성하다보면 자주 사용되는 로직이 있다. 그럼 이 로직을 재사용할 수 있다면 좀 더 효율적인 개발이 가능한데, 재사용이 가능하도록 만든 로직을 라이브러리(library)라고 생각하면 된다. 라이브러리는 자기 자신이 사용하기위해 직접 만들 수 있고, 불특정 다수가 사용할 수 있도록 공개할 수 있다. 라이브러리를 사용하면 필요한 로직을 직접 구현할 필요가 없기 때문에 개발기간을 단축할 수 있을 뿐더러 라이브러리에서 제공하는 API를 호출하는 것을 통해 원하는 기능을 사용할 수 있게된다.

## 확장자별 라이브러리 구분

* .a : 리눅스 / 정적 라이브러리
* .so : 리눅스 / 동적 라이브러리
* .lib : 윈도우 / 정적 라이브러리
* .dll : 윈도우 / 동적 라이브러리

## 정적 라이브러리(Static Library)

정적 라이브러리(static library)는 **프로그램 빌드시에 라이브러리가 제공하는 코드를 실행 파일에 넣는 방식의 라이브러리**이다. 컴파일의 링킹 단계에서 실행파일에 결합되는데, 라이브러리(.lib파일)를 실행 바이너리에 포함시킨다는 의미이다. 즉, 라이브러리의 동작 코드가 이를 사용하는 실행 바이너리 속에 포함되기 때문에 별도의 추가 작업없이 독립적으로 라이브러리 함수들을 사용할 수 있다. 정적 라이브러리를 사용하게 되면 컴파일시 링커가 프로그램이 필요한 부분을 라이브러리에서 찾아 실행파일에 바로 복사한다. 실행파일에 모두 포함되기 때문에 실행시에 라이브러리가 필요없다.

### 장점
1. 동적 라이브러리에 비해 **속도**가 빠르다. 런타임시에 외부를 참조할 필요가 없기 때문에 속도가 향상되어 성능도 좋아진다.
2. 라이브러리 생성이 간단하여 복잡하지않다.
3. 필요한 라이브러리를 프로그램 내에 적재하기 때문에 **이식성**이 좋다. 컴파일시 해당 정적 라이브러리의 내용이 실행 바이너리 안에 포함되어있기 때문에 함께 배포하지 않아도된다.
4. 완성된 애플리케이션을 **안정적**으로 사용할 수 있다. 또한 시스템 환경이 변하더라도 애플리케이션에는 어떠한 영향도 미치지않는다.

### 단점
1. **메모리가 낭비**될 수 있다. 같은 코드를 가진 여러 프로그램을 실행할 경우에 소스코드가 중복되기 때문에 그만큼의 하드디스크 공간도 차지하고, 메모리도 더 많이 차지하게 되어 메모리를 낭비하게 된다.
2. 라이브러리에 변경사항이 생길 경우, 변경된 라이브러리의 내용만 **재배포가 되지않는다**. 즉, 변경된 내용의 라이브러리가 적용된 프로그램을 다시 재배포해야한다.

## 동적 라이브러리

동적 라이브러리(dynamic library)는 **소프트웨어의 일종으로, 동적 링크를 사용한 라이브러리**이다. 여러 프로그램이 공통적으로 필요로 하는 기능들을 프로그램과 분리하여 필요할 때에만 불러내어 쓸 수 있게 만들어 놓은 라이브러리를 의미한다. 마이크로소프트 윈도우에서는 동적 링크 라이브러리라고 해서 확장자가 `DLL`인 파일로 제공되고 있으며, 리눅스에선 `/lib` 밑의 `.so` 파일 등으로 구현된다. 개인이 자유 소프트웨어 등을 작성할 때에 만들기 쉽게 하기위해 작성하여 무료로 제공되는 것도 있다.

### 장점
1. **메모리를 절약**할 수 있으며, 스와핑을 줄여준다. 여러 프로세스가 메모리에 있는 하나의 DLL 복사본을 공유하여 하나의 DLL을 동시에 사용할 수 있다.
2. **디스크 공간도 절약**할 수 있다. 여러 응용 프로그램이 디스크에 있는 하나의 DLL 복사본을 공유할 수 있다.
3. DLL을 쉽게 **업그레이드**할 수 있다. DLL의 함수가 변경되어도 함수의 인수 및 반환 값이 변경되지않았다면 그 함수를 사용하는 응용 프로그램은 다시 컴파일하거나 링크를 할 필요가 업다.
4. 출시 후에 지원이 가능하다. 예를들면, 응용 프로그램을 출시할 때 사용할 수 없었던 디스플레이 기능을 지원하도록 디스플레이 드라이버 DLL을 수정할 수 있다. 
5. 언어 형식이 다른 여러 프로그램을 지원한다. 서로 **다른 프로그래밍 언어**로 작성된 프로그램인 경우에도 함수의 호출 규칙을 따르기만 한다면 여러 프로그램에서 동일한 DLL 함수를 호출할 수 있다. 이 경우 각 프로그램과 DLL 함수는 여러 부분에서 호환될 수 있어야 한다.

### 단점
1. 외부 **의존도가 발생**하기 때문에 이식성이 어렵다.
2. 성능저하로 인해 **속도가 느려질수있다**. 동적 라이브러리는 정적 라이브러리에 비해 사용이 복잡하기 때문에 공유 라이브러리를 메모리에 올리려면 해당 라이브러리를 찾고 올리는데까지 시간이 걸린다. 이로인해 성능저하가 발생하게 되며 속도가 현저히 느려진다.
3. 실행파일을 배포할 경우 **라이브러리를 함께 배포**해야한다. 컴파일시 해당 동적 라이브러리의 내용이 실행 파일안에 포함되어 있지않거나 메이저 버전이 달라 프로그램이 작동되지않는 경우가 있기 때문이다.